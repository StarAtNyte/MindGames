from abc import ABC, abstractmethod
import re

STANDARD_GAME_PROMPT = "You are a competitive game player. Make sure you read the game instructions carefully, and always follow the required format."

class Agent(ABC):
    """ Generic agent class that defines the basic structure of an agent """
    @abstractmethod
    def __call__(self, observation: str) -> str:
        """
        Process the observation and return the action.

        Args:
            observation (str): The input string to process.

        Returns:
            str: The response generated by the agent.
        """
        pass

class LLMAgent(Agent):
    def __init__(self, model_name: str, device: str = "auto", quantize: bool = False, max_new_tokens: int = 1024,
                 hf_kwargs: dict = None,):
        """
        Initialize the Hugging Face local agent.
        
        Args:
            model_name (str): The name of the model.
            device (str): Device to use for model inference (default: "auto").
            quantize (bool): Whether to load the model in 8-bit quantized format (default: False).
        """
        super().__init__()
        
        try:
            from transformers import pipeline, AutoTokenizer, AutoModelForCausalLM
        except ImportError:
            raise ImportError("Transformers library is required. Install it with: pip install transformers")
            
        ## Initialize the Hugging Face model and tokenizer
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        if quantize: self.model = AutoModelForCausalLM.from_pretrained(model_name, load_in_8bit=True, device_map=device, **hf_kwargs)
        else: self.model = AutoModelForCausalLM.from_pretrained(model_name, device_map=device, **hf_kwargs)
        self.system_prompt = STANDARD_GAME_PROMPT
        self.pipeline = pipeline('text-generation', max_new_tokens=max_new_tokens, model=self.model, tokenizer=self.tokenizer) ## Initialize the Hugging Face pipeline
    
    def __call__(self, observation: str) -> str:
        """
        Process the observation using the Hugging Face model and return the action.
        
        Args:
            observation (str): The input string to process.
        
        Returns:
            str: The response generated by the model.
        """
        try: # Generate a response
            response = self.pipeline(self.system_prompt+"\n"+observation, num_return_sequences=1, return_full_text=False)
            action = response[0]['generated_text'].strip() # Extract and return the text output
            return self._extract_move(action)
        except Exception as e:
            return f"An error occurred: {e}"

    def _extract_move(self, response: str) -> str:
        """Extract move in bracket format from response"""
        print(f"Debug - Raw response: '{response}'")
        print(f"Debug - Response repr: {repr(response)}")
        
        # Clean the response first
        cleaned = response.strip()
        
        # Look for pattern like [0], [1], etc.
        match = re.search(r'\[([0-8])\]', cleaned)
        if match:
            result = f"[{match.group(1)}]"
            print(f"Debug - Found bracket match: {result}")
            return result
        
        # If no bracket format found, look for single digits
        match = re.search(r'\b([0-8])\b', cleaned)
        if match:
            result = f"[{match.group(1)}]"
            print(f"Debug - Found digit match: {result}")
            return result
        
        # Default fallback
        print("Debug - Using fallback [0]")
        return "[0]"

class ModalAgent(Agent):
    """ Agent that uses Modal Labs GPU to run DeepSeek model """
    def __init__(self, modal_endpoint_url: str):
        """
        Initialize the Modal agent.
        
        Args:
            modal_endpoint_url (str): The URL of your deployed Modal endpoint
        """
        super().__init__()
        self.endpoint_url = modal_endpoint_url
        
        try:
            import requests
        except ImportError:
            raise ImportError("Requests library is required. Install it with: pip install requests")
        
        self.requests = requests

    def __call__(self, observation: str) -> str:
        """
        Process the observation using the Modal endpoint and return the action.
        
        Args:
            observation (str): The input string to process.
        
        Returns:
            str: The response generated by the model.
        """
        try:
            print(f"🌐 ModalAgent: Calling endpoint {self.endpoint_url}")
            print(f"🌐 ModalAgent: Observation length: {len(observation)} chars")
            
            # Send request to Modal endpoint (add /generate to the URL)
            endpoint_url = self.endpoint_url.rstrip('/') + '/generate'
            response = self.requests.post(
                endpoint_url,
                json={"observation": observation},
                timeout=300  # 5 minute timeout for model inference and warmup
            )
            response.raise_for_status()
            
            result = response.json()
            raw_response = result.get("response", "Error: No response received")
            
            print(f"🌐 ModalAgent: Raw response from endpoint: '{raw_response}'")
            print(f"🌐 ModalAgent: Response length: {len(raw_response)} chars, {len(raw_response.split())} words")
            
            # Extract and format the move properly
            formatted_response = self._extract_move(raw_response)
            print(f"🌐 ModalAgent: Formatted response: '{formatted_response}'")
            return formatted_response
            
        except Exception as e:
            error_msg = f"Error calling Modal endpoint: {str(e)}"
            print(f"❌ ModalAgent error: {error_msg}")
            return error_msg

    def _extract_move(self, response: str) -> str:
        """Extract move in bracket format from response with better validation"""
        print(f"Debug - Modal raw response: '{response}'")
        print(f"Debug - Modal response repr: {repr(response)}")
        
        # Clean the response first
        cleaned = response.strip()
        
        # Look for pattern like [0], [1], etc.
        match = re.search(r'\[([0-8])\]', cleaned)
        if match:
            result = f"[{match.group(1)}]"
            print(f"Debug - Modal found bracket match: {result}")
            return result
        
        # If no bracket format found, look for single digits 0-8
        match = re.search(r'\b([0-8])\b', cleaned)
        if match:
            result = f"[{match.group(1)}]"
            print(f"Debug - Modal found digit match: {result}")
            return result
        
        # Enhanced fallback - try to extract any number
        numbers = re.findall(r'\d+', cleaned)
        if numbers:
            for num_str in numbers:
                num = int(num_str)
                if 0 <= num <= 8:  # Valid player range
                    result = f"[{num}]"
                    print(f"Debug - Modal found number match: {result}")
                    return result
        
        # Default fallback
        print("Debug - Modal using fallback [1]")
        return "[1]"

class HumanAgent(Agent):
    """ Human agent class that allows the user to input actions manually """
    def __init__(self):
        super().__init__()

    def __call__(self, observation: str) -> str:
        """
        Process the observation and return the action.
        
        Args:
            observation (str): The input string to process.
            
        Returns:
            str: The response generated by the agent.
        """
        print("\n\n+++ +++ +++") # for easier visualization of what is part of each turn's observation
        user_input = input(f"Current observations: {observation}\nPlease enter the action (format: [0]-[8]): ")
        
        # Ensure proper formatting
        formatted_move = self._format_move(user_input)
        print(f"Debug - Final formatted move being returned: '{formatted_move}' (repr: {repr(formatted_move)})")
        return formatted_move
    
    def _format_move(self, user_input: str) -> str:
        """Format user input to proper move format"""
        print(f"Debug - Human input: '{user_input}'")
        print(f"Debug - Human input repr: {repr(user_input)}")
        
        # Clean input
        cleaned = user_input.strip()
        
        # If already in bracket format, return as is
        if re.match(r'^\[([0-8])\]', cleaned):
            print(f"Debug - Human already formatted: {cleaned}")
            return cleaned
        
        # Extract number and format
        match = re.search(r'([0-8])', cleaned)
        if match:
            result = f"[{match.group(1)}]"
            print(f"Debug - Human formatted to: {result}")
            return result
        
        # Default fallback
        print("Debug - Human using fallback [0]")
        return "[0]"